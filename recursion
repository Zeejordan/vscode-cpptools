// program of factorial series
/*
#include<bits/stdc++.h>
using namespace std;
int factorial(int n){
    if(n==0){
        return 1;
    }
    return n * factorial(n-1);
}
int main(){
    int n;
    cout<<"Enter the value of n : ";
    cin>>n;
    cout<<factorial(n)<<endl;
    return 0;
}
*/

// program of power of 2
/*
#include<bits/stdc++.h>
using namespace std;
int power(int n){
    // base case
    if(n==0){
        return 1;
    }
    return 2 * power(n-1);
}
int main(){
    int n;
    cout<<"Enter the value of n : ";
    cin>>n;
    int ans = power(n);
    cout<<ans<<endl;
    return 0;
}
*/

// printing count in reverse --> n=5 , 5 4 3 2 1 
/*
#include<bits/stdc++.h>
using namespace std;
void printCount(int n){
    if(n==0){
        return ;
    }
    cout<< n << " ";
    printCount(n-1);
}
int main(){
    int n;
    cout<<"Enter the value of n : ";
    cin>>n;
    
    printCount(n);
    return 0;
}
*/

// printing count in forward --> n=5 , 1 2 3 4 5 
/*
#include<bits/stdc++.h>
using namespace std;
void printCount(int n){
    if(n==0){
        return ;
    }
    printCount(n-1);
    cout<<n<<" ";
}
int main(){
    int n;
    cout<<"Enter the value of n : ";
    cin>>n;
    
    printCount(n);
    return 0;
}
*/
/*
#include<bits/stdc++.h>
using namespace std;
int fibonacci(int n){ 
    if(n==0){return 0;} // base condition
    if(n==1){return 1;} // base condition
    
    int ans = fibonacci(n-1) + fibonacci(n-2);
    return ans;
}
int main(){
    int n;
    cout<<"Enter the value of n : ";
    cin>>n;
    cout<< fibonacci(n)<<endl;
    return 0;
}
*/

/*
Count Ways To Reach The N-th Stairs :-
You have been given a number of stairs. Initially, you are at the 0th stair, and you need to reach the Nth stair. Each time you can either climb one step or two steps. You are supposed to return the number of distinct ways in which you can climb from the 0th step to Nth step.
Example :
N=3

We can climb one step at a time i.e. {(0, 1) ,(1, 2),(2,3)} or we can climb the first two-step and then one step i.e. {(0,2),(1, 3)} or we can climb first one step and then two step i.e. {(0,1), (1,3)}.
Sample Input 1 :
2
2
3
Sample Output 1 :
2
3

Solution :
int countDistinctWayToClimbStair(long long nStairs)
{
    if(nStairs<0){
        return 0;
    }
    if(nStairs==0){
        return 1;
    }
    
    return countDistinctWayToClimbStair(nStairs-1) + countDistinctWayToClimbStair(nStairs-2);
}
*/
/*
Q.Say digits :- 
 input - 412 
output - four one two

#include<bits/stdc++.h>
using namespace std;
void sayDigits(int n , string arr[]){
    // base case
    if(n==0){
        return;
    }
    // processing
    int digit = n % 10;
    n = n / 10;
   
    // recursive call
    sayDigits(n,arr);
    cout<<arr[digit]<<" ";

}
int main(){

    string arr[10] = {"zero","one","two","three","four","five","six","seven","eight","nine"};

    int n;
    cout<<"Enter the value of n : ";
    cin>>n;
    
    cout<<endl;
    sayDigits(n,arr);
    cout<<endl;

    return 0;
}
*/
/*
// to check sorted array
#include<bits/stdc++.h>
using namespace std;
bool isSorted(int arr[] , int n){
     //base case
     if(n==0 || n==1){
         return true;
     }
     if(arr[0] > arr[1]){
         return false;
     }
     else{
         return isSorted(arr+1,n-1);
     }
}
int main(){
    int arr[6]={2,5,7,9,18,54};
    int n = 6;
    bool ans = isSorted(arr,n);
    if(ans){
        cout<<"Array is sorted "<< endl;
    }
    else{
        cout<<"Array is not sorted " << endl;
    }
    return 0;
}
*/
/*
// sum of array :-
// input - arr[]={2,4,7,21,5};
// output - 39

#include<bits/stdc++.h>
using namespace std;
int sumArray(int *arr , int n){
    if(n==0){ // base case
        return 0;
    }
    if(n==1){ // base case
        return arr[0];
    }
    
    int sum = arr[0] + sumArray(arr+1,n-1);
    return sum;
}
int main(){
    int arr[]={2,4,7,21,6};
    int n = 5;
    cout<<sumArray(arr,n)<<endl;
    return 0;
}
*/
/*
// Linear search using recursion.
// input - arr[] = {3,5,7,2,98} , key = 7
// output - found

#include<bits/stdc++.h>
using namespace std;
bool linearSearch(int arr[] , int n , int key){
    if(n==0){
        return false;
    }
    if(arr[0] == key){
        return true;
    }
    else{
        return linearSearch(arr+1,n-1,key);
    }
}
int main(){
    int arr[] = {3,5,7,2,98};
    int key = 20;
    
    cout<<linearSearch(arr,5,key)<<endl;
    return 0;
}
*/
/*
 binary search using recursion

#include<bits/stdc++.h>
using namespace std;
int binarySearch(int arr[],int n,int key,int s,int e){
    int mid = s + (e-s)/2;
    if(s>e){
        return -1;
    }
    if(arr[mid] == key){
        return mid;
    }
    else if(arr[mid] < key){
        return binarySearch(arr,n,key,mid+1,e);
    }
    else{
        return binarySearch(arr,n,key,s,mid-1);
    }
}
int main(){
    int arr[7] = {2,5,7,88,90,100,208};
    int n = 7,s=0,e=6;
    int key = 100;
    cout<<binarySearch(arr, n, key,s,e)<<endl;
    return 0;
}
*/
/*
// Recursion and strings
Q.1 Reverse string :-
 input - abcde
 output - edcba
#include<bits/stdc++.h>
using namespace std;
void reverse(string &s,int i, int j){
      if(i>j){
          return ;
      }
      swap(s[i],s[j]);
      return reverse(s,i+1,j-1);
}
int main(){
    string s = "abcde";
    int i=0;
    reverse(s,i,s.length()-1);
    cout<<s<<endl;
    return 0;
}

Q.2 Check Palindrome.(using recursion)
#include<bits/stdc++.h>
using namespace std;
bool checkPalindrome(string& s , int i , int j){
    if(i>j){
        return true; // this is because , till here we know all the characters are equal of s[i] == s[j] so we return true
    }
    if(s[i] != s[j]){
      return false;  
    }
    else{
        return checkPalindrome(s,i+1,j-1);
    }
}
int main(){
    string s = "abbacabba"; 
    int i = 0 , j = s.length()-1;
    cout<<checkPalindrome(s,i,j)<<endl;
    return 0; 
}

Q.3 power exponentiation.
#include<bits/stdc++.h>
using namespace std;
int power(int a , int b){
    if(b==0){
        return 1;
    }
    if(b==1){
        return a;
    }
    // recursive call
    int ans = power(a,b/2);

    // when b is even
    if(b%2==0){
        return ans * ans;
    }
    
    // when b is odd
    else{
        return a * ans * ans;
    }
}
int main(){
    int a = 3 , b = 4; // answer = 3 x 3 x 3 x 3 => 81
    cout<<power(a,b)<<endl;
    return 0;
}

Q.4 Bubble sort. (using recursion)
#include<bits/stdc++.h>
using namespace std;
void bubbleSort(int arr[] , int n ){
        // base case - already sorted
        if(n == 0 || n == 1){
            return ;
        }

        // ek case solve karlia - largest element apni sahi jagah pe pohuch gaya
        for(int i=0;i<n-1;i++){
            if(arr[i] > arr[i+1]){
                swap(arr[i],arr[i+1]);
            }
        }
         
        // recursive call
        return bubbleSort(arr,n-1); 
    }
int main(){
   int arr[5]={5,3,0,4,1};
   bubbleSort(arr,5);
   for(int i=0;i<5;i++){
       cout<<arr[i]<<" ";
   } 
   return 0;
}
*/
/*
Q.4 Subsets:-
Given an integer array nums of unique elements, return all possible subsets (the power set).
The solution set must not contain duplicate subsets. Return the solution in any order.

Example 1:
Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

Example 2:
Input: nums = [0]
Output: [[],[0]]

Solution: 
class Solution {
private: 
    void solve(vector<int>nums,vector<int>output,int index,vector<vector<int>>&ans){
        // base case
         if(index >= nums.size()){
             ans.push_back(output);
             return ;
         }
        
        // exclude
        solve(nums,output,index+1,ans);

        // include
        int element = nums[index];
        output.push_back(element);
        solve(nums,output,index+1,ans);
    }
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>>ans;
        vector<int>output;
        int index = 0;
        
        solve(nums,output,index,ans);
        return ans;
    }
};

Another variation of above question:-
Subsequences of String :-
You are given a string 'STR' containing lowercase English letters from a to z inclusive. Your task is to find all non-empty possible subsequences of 'STR'.
A Subsequence of a string is the one which is generated by deleting 0 or more letters from the string and keeping the rest of the letters in the same order.
Sample Input :
1 
abc
Sample Output :
a ab abc ac b bc c

Solution:
void solve(string str,string output,int index,vector<string>&ans){
    // base case
    if(index >= str.size()){
        if(output.size() > 0){
            ans.push_back(output);
        }
        return ;
    }
    //exclude
    solve(str,output,index+1,ans);

    // include
    char character = str[index];
    output.push_back(character);
    solve(str,output,index+1,ans);
}
vector<string> subsequences(string str){
    vector<string>ans;
    string output = "";
    int index = 0;
    
    solve(str,output,index,ans);
    return ans;
}
*/
/*
Q.5 Letter Combinations of a Phone Number :-
Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.
A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

Example 1:
Input: digits = "23"
Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]

Example 2:
Input: digits = ""
Output: []

Solution:
class Solution {
private:
    void solve(string digits,string output,int index,vector<string>&ans,string mapping[]){
         // base case
         if(index >= digits.size()){
             ans.push_back(output);
             return;
         }
         int number = digits[index] - '0';
         string value = mapping[number];
         for(int i=0;i<value.size();i++){
             output.push_back(value[i]);
             solve(digits,output,index+1,ans,mapping);
             output.pop_back();
         }
    }
public:
    vector<string> letterCombinations(string digits) {
        vector<string>ans;
        if(digits.size()==0){
            return ans;
        }
        string output="";
        int index=0;
        string mapping[10]={"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
        solve(digits,output,index,ans,mapping);
        return ans;
    }
};
*/
/*
Q.6 Permutations:-
Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.

Example 1:
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

Example 2:
Input: nums = [0,1]
Output: [[0,1],[1,0]]

Example 3:
Input: nums = [1]
Output: [[1]]

Solution:
class Solution {
private:
    void solve(vector<int> nums,int index,vector<vector<int>>&ans){
        if(index >= nums.size()){
            ans.push_back(nums);
            return ;
        }
        for(int j=index;j<nums.size();j++){
            swap(nums[index],nums[j]);
            solve(nums,index+1,ans);
            swap(nums[index],nums[j]);  // backtracking
        }
    }
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>>ans;
        int index = 0;
        solve(nums,index,ans);
        return ans;
    }
};
*/
/*
Q.7 Rat in a Maze Problem :-
Consider a rat placed at (0, 0) in a square matrix of order N * N. It has to reach the destination at (N - 1, N - 1). Find all possible paths that the rat can take to reach from source to destination. The directions in which the rat can move are 'U'(up), 'D'(down), 'L' (left), 'R' (right). Value 0 at a cell in the matrix represents that it is blocked and rat cannot move to it while value 1 at a cell in the matrix represents that rat can be travel through it.
Note: In a path, no cell can be visited more than one time. If the source cell is 0, the rat cannot move to any other cell.

Your Task:  
You don't need to read input or print anything. Complete the function printPath() which takes N and 2D array m[ ][ ] as input parameters and returns the list of paths in lexicographically increasing order. 
Note: In case of no path, return an empty list. The driver will output "-1" automatically.
#include<bits/stdc++.h>
using namespace std;
class Solution{
    private:
       bool isSafe(int x, int y,vector<vector<int>>m,vector<vector<int>>visited,int n){
           if((x>=0 && x<n) && (y>=0 && y<n) && visited[x][y] == 0 && m[x][y]==1 ){
               return true;
           }
           else{
               return false;
           }
       }
       void solve(int srcx,int desy,vector<vector<int>>visited,vector<string>&ans,string path,vector<vector<int>>m,int n){
           if(srcx == n-1 && desy == n-1){
               ans.push_back(path);
               return ;
           }
           // x or y coordinates pe aagaye
           visited[srcx][desy] = 1;

           // for down
           int newx = srcx+1 , newy = desy;
           if(isSafe(newx,newy,m,visited,n)){
               path.push_back('D');
               solve(newx,newy,visited,ans,path,m,n);
               path.pop_back();
           }
           // for up
           newx = srcx-1 , newy = desy;
           if(isSafe(newx,newy,m,visited,n)){
               path.push_back('U');
               solve(newx,newy,visited,ans,path,m,n);
               path.pop_back();
           }
           // for left
            newx = srcx , newy = desy-1;
           if(isSafe(newx,newy,m,visited,n)){
               path.push_back('L');
               solve(newx,newy,visited,ans,path,m,n);
               path.pop_back();
           }
           // for right
           newx = srcx , newy = desy+1;
           if(isSafe(newx,newy,m,visited,n)){
               path.push_back('R');
               solve(newx,newy,visited,ans,path,m,n);
               path.pop_back();
           }

           visited[srcx][desy]=0; // backtracking concept
       }
    public:
    vector<string> findPath(vector<vector<int>> &m, int n) {
        vector<string>ans;
        int srcx = 0;
        int desy = 0;

        if(m[0][0]==0){
            return ans;
        }
        
        vector<vector<int>> visited = m;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                visited[i][j] = 0;
            }
        }
        
        string path = "";
        solve(srcx,desy,visited,ans,path,m,n);
        sort(ans.begin(),ans.end());
        return ans;
    }
};
*/
